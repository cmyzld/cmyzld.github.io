---
layout: article
title: 单生产者单消费者无锁队列
aside:
  toc: true
tags: lock-free-queue
---

在多线程访问同一块数据时，往往需要加锁来保证数据一致性，但在特殊场景下，队列可以lock-free地实现线程安全。这里是真正的线程安全，不需要依靠CAS操作、内存屏障这些操作系统提供的设施来实现。
<!--more-->

## 场景
所谓的特殊场景，就是只有**单个生产者，单个消费者**。这里介绍一下我在工作中遇到的一种场景，一个高并发的TCP长连接服务中：
1. Listener线程监听某一端口上的新连接，并建立好连接。
2. 根据某种负载均衡策略选择Worker来为新连上来的客户端提供服务。
3. 将新连接加入到对应Worker的队列中，并告知它，队列中有新连接了，赶快来处理。
```mermaid
graph TB;
    A[Listener]
    B[Worker1]
    C[Worker2]
    D[Worker3]
    E[Worker4]
    A--连接队列-->B;
    A--连接队列-->C;
    A--连接队列-->D;
    A--连接队列-->E;
```
这里每个Worker具备一个队列，是一个典型的单生产者单消费者场景, 这样的队列是可以完全无锁实现的，无锁的好处，提升性能，不会死锁等等。

在这个场景下，无锁并不会带来太大的性能收益。尽管如此，迈出这一步对自己总有好处.
{:.warning}

## 无锁的原理
``` 
              -----+---------+---------+---------+---------+----------+---------+-----
    Worker <--     |  conn1  |  conn2  |  conn3  |  conn4  |  conn5   |  conn6  |         <--- Listener
              -----+---------+---------+---------+---------+----------+---------+-----
                      out                                                           in 
             
```
1. Listener从in指针处往后写数据，修改in指针。
2. Worker从out处取数据，修改out指针。
3. 有效数据位于[out, in)这个左闭右开区间内。

Listener每次往队列中插入一条数据后，通知Worker有新数据。Worker被唤醒后，需要知道队列中具体有多少条数据以尽量一次性取完，这时候我知道的有两种比较好的方案：
1. Worker读取in指针，直接计算队列的size.

{% highlight C++ %}
buffer[in] = new_connection;
in = in + 1;
{% endhighlight %}


2. 使用eventfd，由内核来维护计数器，同时也可以实现通知的功能。
