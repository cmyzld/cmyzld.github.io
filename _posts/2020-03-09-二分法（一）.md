---
layout: article
title: 二分法（一）
aside:
  toc: true
tags: Binary Search
---
<!-- more !-->
## 基本查找问题
### LC.704 Binary Search
二分查找模板题
{% highlight C++ %}
int search(vector<int>& nums, int target) {
    int i = 0, j = nums.size() - 1;
    while(i + 1 < j)
    {
        int mid = i + (j - i) / 2;
        if(nums[mid] == target) return mid;
        else if(nums[mid] > target) j = mid;
        else i = mid;
    }
    if(nums[i] == target) return i;
    if(nums[j] == target) return j;
    return -1;
}
{% endhighlight %}

### LC.35 Search Insert Position
{% highlight C++ %}
int search(vector<int>& nums, int target) {
    int lo = 0, hi = nums.size() - 1;
    while(lo + 1 < hi)
    {
        int mid = lo + (hi - lo) / 2;
        if(target > nums[mid]) lo = mid;
        else if(target < nums[mid]) hi = mid;
        else return mid;
    }
    if(target <= nums[lo]) return lo;
    else if(target <= nums[hi]) return hi;
    return hi + 1;
}
{% endhighlight %}
本题要求target不在数组中的时候，返回target的插入位置。查找过程与上题相同，但在for循环结束后，区间被缩小到[lo, hi], 且区间长度不超过2，这时分以下几种情况：

1. target < nums[lo]  target应插入在lo的位置
2. target == nums[lo] or target == nums[hi] 查找成功
3. nums[lo] < target < nums[hi] target插入在lo后面，也就是lo + 1的位置
4. target > nums[hi] target插入到hi的后面


