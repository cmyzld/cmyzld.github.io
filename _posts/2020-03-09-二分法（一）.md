---
layout: article
title: 二分法（一）
aside:
  toc: true
tags: Binary Search
---
<!-- more !-->
## 基本查找问题
### LC.35 [Search Insert Position](https://leetcode.com/problems/search-insert-position/)
{% highlight C++ %}
int search(vector<int>& nums, int target) {
    int lo = 0, hi = nums.size() - 1;
    while(lo + 1 < hi)
    {
        int mid = lo + (hi - lo) / 2;
        if(target > nums[mid]) lo = mid;
        else if(target < nums[mid]) hi = mid;
        else return mid;
    }
    if(target <= nums[lo]) return lo;
    else if(target <= nums[hi]) return hi;
    return hi + 1;
}
{% endhighlight %}
本题要求target不在数组中的时候，返回target的插入位置。在for循环结束后，区间被缩小到[lo, hi], 且区间长度不超过2，这时分以下几种情况：

1. target < nums[lo]  target应插入在lo的位置
2. target == nums[lo] or target == nums[hi] 查找成功
3. nums[lo] < target < nums[hi] target插入在lo后面，也就是lo + 1的位置
4. target > nums[hi] target插入到hi的后面

### LC Search for a Range
在有序数组中查找target的下标范围。首先，可以先查找任意一个target下标，然后分别向两边扩展，但最坏情况下，整个数组都等于target，复杂度将退化到O(N<sup>2</sup>). 

