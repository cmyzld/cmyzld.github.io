---
layout: article
title: 有序序列归并问题
aside:
  toc: true
tags: Algorithm
---

## 如何合并两个有序序列，结果仍然有序？
在归并排序中，我们先将待排序数组平均划分为两半，然后递归地去排序两个子数组，最后将排序好的子数组归并成完整的排序数组。合并步骤作为归并排序的核心，我们有O(N)的算法来实现.
<!--more-->

Merge A[1..N] and B[1..M] into C[1..M + N - 1]<br>
&emsp;&emsp;i = 1, j = 1, k = 1<br>
&emsp;&emsp;while(i <= N && j <= M)<br>
&emsp;&emsp;&emsp;&emsp;if(A[i] ≤ B[j]) C[k++] = A[i++] <br>
&emsp;&emsp;&emsp;&emsp;else C[k++] = B[j++]<br>
&emsp;&emsp;while(i ≤ N) C[k++] = A[i++]<br>
&emsp;&emsp;while(j ≤ M) C[k++] = B[j++]<br>
{:.warning}
思想很简单，归并后的最小元素肯定是 A 的最小元素和 B 的最小元素之间的较小者，所以只需从未归并部分不断比较出较小者加入C即可。除了归并排序，这个问题还有一些变种，比如 K 路归并等。

### LC.21 [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists)
和普通的归并算法类似，从两个链表的头部摘下较小节点，链接在结果链表的尾部，不同的是仅需要常数的额外空间。
{% highlight c++ linenos %}
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode *result, *tail;
    result = tail = new ListNode(0);
    while(l1 && l2){
        if(l1->val <= l2->val){
            tail->next = l1;
            tail = l1;
            l1 = l1->next;
        }
        else{
            tail->next = l2;
            tail = l2;
            l2 = l2->next;
        }
    }
    if(l1) tail->next = l1;
    if(l2) tail->next = l2;
    return result->next;
}
{% endhighlight %}
抛开链表和数组实现上的差异来看，背后的算法原理一模一样。
### LC.88 [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array)

nums1 = [1,2,3,0,0,0], m = 3     ==>     nums1 = [1,2,2,3,5,6], m = 6 <br>
nums2 = [2,5,6],       n = 3
{:.info}

题意是nums1中有足够的空间，要求将nums2归原地归并入nums1中。若是前向归并，最坏情况下，nums2中的每个元素都插入到nums1的开头，nums1的元素要往后腾出空间，复杂度是O(mn). 

### LC.23 [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists)

### LC.378 [Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix)

