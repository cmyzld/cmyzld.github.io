---
layout: article
title: 有序序列归并问题
aside:
  toc: true
tags: Algorithm
---

## 如何合并两个有序序列，结果仍然有序？
在归并排序中，我们先将待排序数组平均划分为两半，然后递归地去排序两个子数组，最后将排序好的子数组归并成完整的排序数组。合并步骤作为归并排序的核心，我们有O(N)的算法来实现：

Merge A[1..N] and B[1..M] into C[1..M + N - 1]<br>
&emsp;&emsp;i = 1, j = 1, k = 1<br>
&emsp;&emsp;while(i <= N && j <= M)<br>
&emsp;&emsp;&emsp;&emsp;if(A[i] ≤ B[j]) C[k++] = A[i++] <br>
&emsp;&emsp;&emsp;&emsp;else C[k++] = B[j++]<br>
&emsp;&emsp;while(i ≤ N) C[k++] = A[i++]<br>
&emsp;&emsp;while(j ≤ M) C[k++] = B[j++]<br>
{:.warning}
思想很简单，归并后的最小元素肯定是 A 的最小元素和 B 的最小元素之间的较小者，所以只需从未归并部分不断比较出较小者加入C即可。

{% highlight C %}
merge(A[1..N], B[1..M], C[1..M + N - 1])
    i = 1, j = 1, k = 1
    while(i <= N && j <= M)
        if(A[i] ≤ B[j]) C[k++] = A[i++]
        else C[k++] = B[j++]
    while(i ≤ N) C[k++] = A[i++]
    while(j ≤ M) C[k++] = B[j++]
{% endhighlight %}

```C++
    int minMeetingRooms1(vector<vector<int>>& intervals) {
        int n = intervals.size();
        if(n <= 1) return n;
        unordered_map<int, int> count;
        for(auto v: intervals)
        {
            for(int l = v[0]; l < v[1]; l += 1)
            {
                if(count.find(l) == count.end())
                    count[l] = 0;
                count[l] += 1;
            }
        }
        int ans = 0;
        for(auto it = count.begin(); it != count.end(); it ++)
            ans = max(ans, it->second);
        return ans;
    }
```
## Head2
### Head 2.1
