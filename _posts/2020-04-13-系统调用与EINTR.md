---
layout: article
title: 系统调用与EINTR
aside:
  toc: true
tags: linux
---
## 文章目标
* 弄明白EINTR的作用
* 什么情况下系统调用会被信号中断，中断后返回什么值
* 非阻塞的系统调用是否会返回EINTR
<!--more-->

## EINTR简介
最近在项目中用到eventfd，timerfd，以及socket三种文件，使用read系统调用来读取数据时，必须正确处理errno. read调用会发生的errno比较多，EINTR是比较重要的一个。查阅read函数的man手册(man 2 read), 对EINTR的描述如下：
> EINTR  The call was interrupted by a signal before any data was read; see signal(7)

这是一个不太精确而又笼统的描述，同为系统调用，为什么bind不会返回EINTR，这其中的差异在何处？顺藤摸瓜，查看signal的man手册(man 7 signal), 其中对中断的系统调用有稍微详细一些的描述，来逐条看一下。
> If a signal handler is invoked while a system call or library function call is blocked, then either:
> * the call is automatically restarted after the signal handler returns; or
> * the call fails with the error EINTR.

注意这里的说法，说的是“while a system call is blocked”，那么系统调用要么直接返回EINTR（用户空间errno会设置为EINTR），要么被自动重启（内核会负责自动重启，对用户空间是透明的）。



## 案例分析——read
### 公共部分
### eventfd
### timerfd
### socket
### epoll
### select 
### poll
## 系统调用重启
## 结论
